package main

func chowla(n i32) (out i32) {
    if n < 1 {
        out = -1
		return
    }
	
    var sum i32
	var c i32
	var i i32
	var j i32
    for i = 2; i*i <= n; i++ {
		c = i32.mod(n, i)
        if i32.eq(c, 0) {
            j = i32.div(n, i)
			
            if i32.eq(i, j){
                sum = i32.add(sum, i)
            } else {
                sum = i32.add(sum, i32.add(i, j))
            }
        }
    }
	out = sum
}


func sieve(limit i32) (out []bool) {
    // True denotes composite, false denotes prime.
    // Only interested in odd numbers >= 3
    var c []bool
	var i i32
	var j i32
	var ch i32

	// initialize value for bool slice
	for i = 0; i < limit; i++ {
		c = append(c,false)
	}

	var iii i32 = 3
    for i = 3; iii < limit; {
		ch = chowla(i)
        if c[i] == false && i32.eq(ch, 0) {
			j = i32.mul(i,3)
            for ; j < limit; {
                c[j] = true
				j = i32.add(j, i32.mul(2,i))
            }
        }

		i = i32.add(i,2)
		iii = i32.mul(i,3)
    }

	for i = 0; i < limit; i++ {
		out = append(out, c[i])
	}
}

func commatize(n i32) (out str) {
    var s str
	s = i32.str(n)
	
    var l i32
	l = len(s)
	
	var i i32
	i = i32.sub(l,3)

	printf("%d\n", i)
    for ; i >= 1; {
		printf("%d\n", i)
		i = i32.sub(i,3)
    }

	out = s
}


func main() {
	var i i32
	var ch i32
	for i = 1; i <= 37; i++ {
		ch = chowla(i)
		//printf("chowla(%d) = %d\n", i, ch)
    }

	var c []bool
    count := 1
	limit := 10000
    c = sieve(limit)
    power := 100

	////////////////////////////////////////////////
	// IMPORTANT: Can't access slice return from method sieve(limit)
	i32.print(len(c))
	for i = 0; i < limit; i++ {
		bool.print(c[i]) 
	}

	
    /*for i = 3; i < limit; {
        if bool.eq(c[i], false) {
			count = i32.add(count,1)	
        }

        if i32.eq(i, i32.sub(power,1)) {
			printf("Count of primes up to %s 10s = %s", commatize(power), commatize(count))
			ttt = commatize(power)
			power = i32.mul(power, 10)
        }
		i = i32.add(i,2)
    }*/
}
